<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>The Nexus Terminal</title>
    <link rel="icon" href="logo.jpg" type="image/jpeg" />
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css2?family=VT323&display=swap"
    />
    <style>
      :root {
        --bg: #050505;
        --panel: #1a1a1a;
        --cyan: #00f3ff;
        --purple: #bd00ff;
        --green: #00ff6a;
        --danger: #ff3b6a;
        --text: #d7f8ff;
        --muted: #7be7ff;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        font-family: "VT323", "Courier New", monospace;
        background: radial-gradient(
            circle at 12% 12%,
            rgba(0, 243, 255, 0.18),
            transparent 45%
          ),
          radial-gradient(
            circle at 85% 18%,
            rgba(189, 0, 255, 0.14),
            transparent 40%
          ),
          linear-gradient(140deg, #050505 10%, #0b0b0b 45%, #050505 100%);
        color: var(--text);
        letter-spacing: 0.6px;
        transition: transform 0.6s ease;
        transform-origin: center;
      }

      body.override {
        transform: rotate(180deg);
      }

      body.sentry {
        background: #000;
      }

      .scanlines {
        position: fixed;
        inset: 0;
        pointer-events: none;
        background: repeating-linear-gradient(
          to bottom,
          rgba(255, 255, 255, 0.04),
          rgba(255, 255, 255, 0.02) 2px,
          rgba(0, 0, 0, 0.12) 4px
        );
        mix-blend-mode: overlay;
        opacity: 0.3;
        z-index: 5;
      }

      .sentry-video {
        position: fixed;
        inset: 0;
        width: 100%;
        height: 100%;
        object-fit: cover;
        z-index: 1;
        opacity: 0;
        transition: opacity 0.4s ease;
        filter: grayscale(1) contrast(1.1) brightness(0.55) sepia(0.4)
          hue-rotate(165deg) saturate(1.5);
      }

      body.sentry .sentry-video {
        opacity: 1;
      }

      .reticle {
        position: fixed;
        width: 140px;
        height: 140px;
        border: 1px solid rgba(0, 243, 255, 0.7);
        box-shadow: 0 0 12px rgba(0, 243, 255, 0.35);
        pointer-events: none;
        opacity: 0;
        z-index: 12;
        transition: opacity 0.2s ease;
        transform: translate(-50%, -50%);
      }

      .reticle::before,
      .reticle::after {
        content: "";
        position: absolute;
        background: rgba(0, 243, 255, 0.6);
      }

      .reticle::before {
        left: 10%;
        right: 10%;
        top: 50%;
        height: 1px;
      }

      .reticle::after {
        top: 10%;
        bottom: 10%;
        left: 50%;
        width: 1px;
      }

      .reticle.active {
        opacity: 1;
      }

      .app {
        max-width: 1280px;
        margin: 0 auto;
        padding: 32px 24px 110px;
        position: relative;
        z-index: 2;
      }

      header {
        display: flex;
        flex-direction: column;
        gap: 6px;
        margin-bottom: 24px;
        text-transform: uppercase;
        position: relative;
      }

      header h1 {
        margin: 0;
        font-size: 40px;
        color: var(--cyan);
        text-shadow: 0 0 18px rgba(0, 243, 255, 0.6);
      }

      header p {
        margin: 0;
        color: var(--muted);
        font-size: 18px;
      }

      .settings-btn {
        position: absolute;
        top: 0;
        right: 0;
        width: 36px;
        height: 36px;
        border-radius: 50%;
        border: 1px solid rgba(0, 243, 255, 0.6);
        background: rgba(5, 5, 5, 0.75);
        color: var(--cyan);
        font-size: 18px;
        cursor: pointer;
        box-shadow: 0 0 10px rgba(0, 243, 255, 0.3);
      }

      .settings-btn:hover {
        border-color: var(--purple);
        color: var(--purple);
      }

      .command-center {
        position: relative;
        width: 150px;
        height: 150px;
        margin: 12px auto 6px;
        display: flex;
        align-items: center;
        justify-content: center;
        align-self: center;
      }

      .arc-reactor {
        position: absolute;
        inset: 0;
        border-radius: 50%;
        border: 2px solid rgba(0, 243, 255, 0.6);
        box-shadow: 0 0 16px rgba(0, 243, 255, 0.4),
          inset 0 0 12px rgba(0, 243, 255, 0.35);
        animation: arc-breathe 3s ease-in-out infinite;
      }

      .arc-reactor::before,
      .arc-reactor::after {
        content: "";
        position: absolute;
        inset: 14px;
        border-radius: 50%;
        border: 1px dashed rgba(189, 0, 255, 0.5);
      }

      .arc-reactor::after {
        inset: 28px;
        border-style: solid;
        border-color: rgba(0, 243, 255, 0.4);
      }

      .arc-reactor.listening {
        animation: arc-listen 0.8s ease-in-out infinite;
        box-shadow: 0 0 22px rgba(255, 59, 106, 0.6),
          inset 0 0 16px rgba(255, 59, 106, 0.4);
      }

      .arc-reactor.speaking {
        animation: arc-speak 0.45s ease-in-out infinite;
      }

      .arc-reactor.thinking {
        animation: arc-think 0.7s ease-in-out infinite;
        border-color: rgba(255, 199, 64, 0.8);
        box-shadow: 0 0 22px rgba(255, 199, 64, 0.6),
          inset 0 0 18px rgba(255, 199, 64, 0.4);
      }

      .mic-btn {
        position: relative;
        z-index: 1;
        width: 64px;
        height: 64px;
        border-radius: 50%;
        border: 1px solid rgba(0, 243, 255, 0.8);
        background: #0a0a0a;
        color: var(--cyan);
        font-size: 16px;
        letter-spacing: 1px;
        text-shadow: 0 0 8px rgba(0, 243, 255, 0.8);
        box-shadow: 0 0 14px rgba(0, 243, 255, 0.35);
      }

      .mic-btn.recording {
        border-color: var(--danger);
        color: var(--danger);
        box-shadow: 0 0 16px rgba(255, 59, 106, 0.6);
      }

      .hud-panels {
        display: flex;
        gap: 12px;
        justify-content: center;
        flex-wrap: wrap;
        margin-top: 6px;
      }

      .hud-panel {
        min-width: 180px;
        padding: 10px 12px;
        background: rgba(5, 5, 5, 0.65);
        border: 1px solid rgba(0, 243, 255, 0.35);
        box-shadow: 0 0 12px rgba(0, 243, 255, 0.12);
        font-size: 14px;
      }

      .hud-title {
        font-size: 16px;
        color: var(--cyan);
        margin-bottom: 6px;
        text-shadow: 0 0 8px rgba(0, 243, 255, 0.5);
      }

      .hud-line {
        margin-bottom: 4px;
        color: var(--text);
      }

      .hud-line:last-child {
        margin-bottom: 0;
      }

      .sentry-control {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 12px;
        margin-top: 8px;
      }

      .sentry-toggle {
        padding: 6px 12px;
        font-size: 16px;
      }

      .sensor-status {
        font-size: 14px;
        color: var(--muted);
      }

      .sensor-status.offline {
        color: var(--danger);
      }

      .grid {
        display: grid;
        grid-template-columns: 3fr 2fr;
        gap: 20px;
      }

      .right-stack {
        display: flex;
        flex-direction: column;
        gap: 20px;
      }

      .panel {
        background: linear-gradient(160deg, #141414, #0f0f0f 60%, #131313);
        border: 1px solid rgba(0, 243, 255, 0.4);
        box-shadow: 0 0 24px rgba(0, 243, 255, 0.08);
        padding: 20px;
        position: relative;
        overflow: hidden;
      }

      .panel::before {
        content: "";
        position: absolute;
        inset: 0;
        border: 1px solid rgba(189, 0, 255, 0.25);
        pointer-events: none;
      }

      .panel h2 {
        margin: 0 0 12px;
        font-size: 26px;
        color: var(--cyan);
        text-shadow: 0 0 10px rgba(0, 243, 255, 0.6);
      }

      .panel-title-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 12px;
      }

      .panel-title-row h2 {
        margin: 0;
      }

      .panel-tag {
        font-size: 14px;
        color: var(--purple);
        text-shadow: 0 0 6px rgba(189, 0, 255, 0.5);
      }

      .memory-input {
        display: flex;
        gap: 10px;
        margin-bottom: 16px;
      }

      input[type="text"],
      input[type="password"],
      textarea {
        width: 100%;
        background: #0a0a0a;
        border: 1px solid rgba(0, 243, 255, 0.5);
        color: var(--text);
        padding: 10px 12px;
        font-family: inherit;
        font-size: 18px;
        outline: none;
        box-shadow: inset 0 0 8px rgba(0, 243, 255, 0.2);
      }

      textarea {
        min-height: 120px;
        resize: vertical;
      }

      button,
      .btn {
        background: #0c0c0c;
        border: 1px solid rgba(189, 0, 255, 0.7);
        color: var(--text);
        padding: 10px 14px;
        font-family: inherit;
        font-size: 18px;
        cursor: pointer;
        text-transform: uppercase;
        position: relative;
        overflow: hidden;
        transition: transform 0.2s ease, box-shadow 0.2s ease,
          border-color 0.2s ease;
        box-shadow: 0 0 10px rgba(189, 0, 255, 0.35);
      }

      button:hover,
      .btn:hover {
        border-color: var(--cyan);
        box-shadow: 0 0 18px rgba(0, 243, 255, 0.45);
        transform: translateY(-1px);
        animation: glitch 0.6s infinite;
      }

      .btn.secondary {
        border-color: rgba(0, 243, 255, 0.55);
        box-shadow: 0 0 10px rgba(0, 243, 255, 0.25);
      }

      .btn.secondary:hover {
        border-color: var(--purple);
        box-shadow: 0 0 18px rgba(189, 0, 255, 0.45);
      }

      .memory-hint {
        margin-bottom: 10px;
        color: var(--muted);
      }

      .data-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
        gap: 12px;
      }

      .data-block {
        border: 1px solid rgba(0, 243, 255, 0.45);
        background: rgba(8, 8, 8, 0.9);
        padding: 10px;
        min-height: 110px;
        position: relative;
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
        box-shadow: 0 0 12px rgba(0, 243, 255, 0.2);
        display: flex;
        flex-direction: column;
      }

      .data-block.code {
        border-color: rgba(189, 0, 255, 0.8);
        box-shadow: 0 0 12px rgba(189, 0, 255, 0.3);
      }

      .data-block.link {
        border-color: rgba(0, 243, 255, 0.9);
      }

      .data-block:hover {
        transform: translateY(-2px);
        box-shadow: 0 0 16px rgba(0, 243, 255, 0.45);
      }

      .block-head {
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 16px;
        margin-bottom: 6px;
        color: var(--muted);
        gap: 8px;
      }

      .block-meta {
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }

      .block-flag {
        font-size: 14px;
        color: var(--cyan);
        text-shadow: 0 0 6px rgba(0, 243, 255, 0.8);
      }

      .block-flag.code {
        color: var(--purple);
      }

      .block-actions {
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }

      .icon-btn {
        width: 32px;
        height: 26px;
        padding: 0;
        font-size: 16px;
        line-height: 1;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        background: #0c0c0c;
        border: 1px solid rgba(0, 243, 255, 0.6);
        color: var(--cyan);
        box-shadow: 0 0 8px rgba(0, 243, 255, 0.25);
      }

      .icon-btn.qr-btn {
        color: var(--cyan);
      }

      .icon-btn.delete-btn {
        border-color: rgba(255, 59, 106, 0.8);
        color: var(--danger);
        box-shadow: 0 0 8px rgba(255, 59, 106, 0.35);
      }

      .icon-btn:hover {
        border-color: var(--purple);
        color: var(--purple);
        box-shadow: 0 0 12px rgba(189, 0, 255, 0.35);
      }

      .icon-btn.delete-btn:hover {
        border-color: var(--danger);
        color: var(--danger);
        box-shadow: 0 0 12px rgba(255, 59, 106, 0.55);
      }
      .block-content {
        font-size: 18px;
        white-space: pre-wrap;
        word-break: break-word;
        margin-top: auto;
      }

      .shatter {
        animation: shatter 0.35s forwards;
      }

      .cipher-tabs {
        display: flex;
        gap: 8px;
        margin-bottom: 16px;
        flex-wrap: wrap;
      }

      .panel-tabs {
        margin-bottom: 18px;
      }

      .panel-tabs .tab-btn {
        letter-spacing: 1px;
      }

      .tab-btn.active {
        border-color: var(--cyan);
        box-shadow: 0 0 16px rgba(0, 243, 255, 0.4);
      }

      .mode-panel {
        display: none;
      }

      .mode-panel.active {
        display: block;
      }

      .field {
        margin-bottom: 14px;
      }

      .field label {
        display: block;
        margin-bottom: 6px;
        color: var(--muted);
      }

      .file-actions {
        display: flex;
        align-items: center;
        gap: 8px;
        flex-wrap: wrap;
      }

      .file-label {
        display: inline-flex;
        align-items: center;
        gap: 8px;
      }

      .file-input {
        display: none;
      }

      .preview {
        width: 100%;
        max-height: 200px;
        object-fit: contain;
        border: 1px solid rgba(0, 243, 255, 0.35);
        background: #050505;
        margin-top: 10px;
        box-shadow: 0 0 14px rgba(0, 243, 255, 0.2);
      }

      .preview.hidden {
        display: none;
      }

      .output {
        background: #0a0a0a;
        border: 1px solid rgba(189, 0, 255, 0.6);
        padding: 12px;
        min-height: 120px;
        white-space: pre-wrap;
        font-size: 18px;
        position: relative;
      }

      .output.typing::after {
        content: "|";
        margin-left: 6px;
        animation: blink 0.9s infinite;
        color: var(--green);
      }

      .transmute-grid {
        display: grid;
        gap: 12px;
      }

      .ai-log {
        border: 1px solid rgba(0, 243, 255, 0.35);
        background: rgba(5, 5, 5, 0.65);
        min-height: 160px;
        max-height: 260px;
        overflow-y: auto;
        padding: 10px;
        display: grid;
        gap: 8px;
        box-shadow: inset 0 0 12px rgba(0, 243, 255, 0.12);
      }

      .ai-entry {
        padding: 6px 8px;
        border: 1px solid transparent;
        background: rgba(10, 10, 10, 0.6);
        font-size: 16px;
        white-space: pre-wrap;
      }

      .ai-entry.user {
        border-color: rgba(189, 0, 255, 0.6);
        color: var(--text);
      }

      .ai-entry.assistant {
        border-color: rgba(0, 243, 255, 0.6);
        color: var(--cyan);
      }

      .ai-entry.system {
        border-color: rgba(0, 255, 106, 0.5);
        color: var(--green);
      }

      .ai-input {
        display: flex;
        gap: 8px;
        margin-top: 12px;
      }

      .ai-input input {
        flex: 1;
      }

      .ai-hint {
        margin-top: 8px;
        font-size: 14px;
        color: var(--muted);
      }

      .protocol-grid {
        display: grid;
        gap: 10px;
      }

      .popup-warning {
        margin-top: 10px;
        padding: 8px 10px;
        border: 1px solid rgba(255, 59, 106, 0.8);
        color: var(--danger);
        background: rgba(20, 5, 8, 0.7);
        text-transform: uppercase;
        letter-spacing: 1px;
        font-size: 14px;
        box-shadow: 0 0 12px rgba(255, 59, 106, 0.25);
      }

      .popup-warning.hidden {
        display: none;
      }

      .trans-output {
        background: #0a0a0a;
        border: 1px solid rgba(0, 243, 255, 0.45);
        padding: 10px 12px;
        min-height: 80px;
        font-size: 16px;
        white-space: pre-wrap;
        word-break: break-word;
        box-shadow: inset 0 0 8px rgba(0, 243, 255, 0.18);
      }

      .trans-output.flicker {
        animation: flicker 0.25s steps(2, end) 2;
      }

      .download-link {
        display: inline-flex;
        margin-top: 10px;
        color: var(--green);
        text-decoration: none;
        font-size: 18px;
        text-shadow: 0 0 8px rgba(0, 255, 106, 0.7);
      }

      .download-link.disabled {
        opacity: 0.5;
        pointer-events: none;
      }

      .toast {
        position: fixed;
        left: 50%;
        bottom: 90px;
        transform: translateX(-50%) translateY(20px);
        background: rgba(0, 0, 0, 0.85);
        border: 1px solid rgba(0, 255, 106, 0.8);
        color: var(--green);
        padding: 10px 16px;
        font-size: 18px;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.2s ease, transform 0.2s ease;
        box-shadow: 0 0 16px rgba(0, 255, 106, 0.5);
        z-index: 20;
      }

      .toast.show {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
      }

      .net-ghost {
        position: fixed;
        top: 12px;
        right: 16px;
        padding: 10px 12px;
        font-size: 14px;
        color: var(--text);
        background: rgba(5, 5, 5, 0.7);
        border: 1px solid rgba(0, 243, 255, 0.35);
        box-shadow: 0 0 16px rgba(0, 243, 255, 0.15);
        z-index: 25;
        min-width: 180px;
      }

      .ghost-header {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-bottom: 6px;
        color: var(--cyan);
        text-shadow: 0 0 8px rgba(0, 243, 255, 0.5);
      }

      .ghost-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: var(--green);
        box-shadow: 0 0 10px rgba(0, 255, 106, 0.7);
        animation: pulse 1.5s ease-in-out infinite;
      }

      .modal {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.78);
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.2s ease;
        z-index: 40;
        padding: 16px;
      }

      .modal.active {
        opacity: 1;
        pointer-events: auto;
      }

      .modal-panel {
        width: min(360px, 92vw);
        background: linear-gradient(160deg, #0e0e0e, #070707);
        border: 1px solid rgba(0, 243, 255, 0.6);
        box-shadow: 0 0 20px rgba(0, 243, 255, 0.25);
        padding: 18px;
        position: relative;
        overflow: hidden;
      }

      .modal-panel h3 {
        margin: 0 0 6px;
        color: var(--cyan);
      }

      .modal-panel p {
        margin: 0 0 12px;
        color: var(--muted);
      }

      .modal-panel::before,
      .modal-panel::after {
        content: "";
        position: absolute;
        inset: -2px;
        opacity: 0;
        pointer-events: none;
        mix-blend-mode: screen;
        background: linear-gradient(
          120deg,
          rgba(0, 243, 255, 0.25),
          rgba(189, 0, 255, 0.22)
        );
      }

      .modal-panel.glitch-in {
        animation: glitch-in 0.45s steps(2, end);
      }

      .modal-panel.glitch-in::before {
        animation: rgb-shift 0.35s ease;
      }

      .modal-panel.glitch-in::after {
        animation: rgb-shift 0.35s ease 0.1s;
      }

      .modal-close {
        position: absolute;
        top: 10px;
        right: 10px;
        width: 28px;
        height: 28px;
        padding: 0;
      }

      .qr-image {
        width: 150px;
        height: 150px;
        border: 1px solid rgba(0, 243, 255, 0.6);
        background: #050505;
        margin-bottom: 12px;
        box-shadow: 0 0 12px rgba(0, 243, 255, 0.35);
      }

      .qr-text {
        font-size: 16px;
        background: rgba(0, 0, 0, 0.6);
        border: 1px solid rgba(189, 0, 255, 0.4);
        padding: 8px;
        max-height: 120px;
        overflow: auto;
        white-space: pre-wrap;
      }

      .override-modal {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.92);
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease;
        z-index: 60;
        padding: 20px;
      }

      .override-modal.active {
        opacity: 1;
        pointer-events: auto;
      }

      .override-panel {
        border: 1px solid rgba(0, 255, 106, 0.7);
        padding: 24px;
        max-width: 720px;
        text-align: center;
        background: rgba(0, 10, 0, 0.6);
        box-shadow: 0 0 20px rgba(0, 255, 106, 0.3);
      }

      .override-title {
        font-size: 20px;
        color: var(--green);
        text-shadow: 0 0 12px rgba(0, 255, 106, 0.6);
      }

      .deploy-overlay {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.85);
        display: flex;
        align-items: center;
        justify-content: center;
        color: var(--cyan);
        font-size: 32px;
        letter-spacing: 4px;
        text-shadow: 0 0 16px rgba(0, 243, 255, 0.8);
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.2s ease;
        z-index: 70;
      }

      .deploy-overlay.active {
        opacity: 1;
      }

      .sonic-footer {
        position: fixed;
        left: 0;
        right: 0;
        bottom: 0;
        height: 60px;
        background: rgba(5, 5, 5, 0.92);
        border-top: 1px solid rgba(0, 243, 255, 0.4);
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0 16px;
        z-index: 15;
        gap: 12px;
      }

      .sonic-footer canvas {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 60px;
        pointer-events: none;
      }

      .footer-label {
        position: relative;
        z-index: 1;
        color: var(--cyan);
        text-shadow: 0 0 10px rgba(0, 243, 255, 0.6);
        font-size: 18px;
      }

      .footer-controls {
        position: relative;
        z-index: 1;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .footer-btn {
        font-size: 16px;
        padding: 6px 10px;
      }

      .audio-status {
        font-size: 16px;
        color: var(--muted);
      }

      @keyframes glitch {
        0% {
          text-shadow: 2px 0 rgba(0, 243, 255, 0.8),
            -2px 0 rgba(189, 0, 255, 0.6);
        }
        50% {
          text-shadow: -2px -1px rgba(0, 243, 255, 0.8),
            2px 1px rgba(189, 0, 255, 0.6);
        }
        100% {
          text-shadow: 1px 0 rgba(0, 243, 255, 0.8),
            -1px 0 rgba(189, 0, 255, 0.6);
        }
      }

      @keyframes glitch-in {
        0% {
          opacity: 0;
          transform: translate(-12px, -8px) skewX(6deg);
          clip-path: polygon(0 2%, 100% 0, 100% 14%, 0 18%);
        }
        40% {
          opacity: 0.6;
          transform: translate(10px, 4px) skewX(-4deg);
          clip-path: polygon(0 32%, 100% 28%, 100% 42%, 0 46%);
        }
        70% {
          opacity: 0.9;
          transform: translate(-6px, 2px) skewX(2deg);
          clip-path: polygon(0 60%, 100% 58%, 100% 76%, 0 72%);
        }
        100% {
          opacity: 1;
          transform: translate(0, 0) skewX(0);
          clip-path: inset(0 0 0 0);
        }
      }

      @keyframes rgb-shift {
        0% {
          opacity: 0.9;
          transform: translate(-6px, 2px);
        }
        100% {
          opacity: 0;
          transform: translate(6px, -2px);
        }
      }

      @keyframes shatter {
        to {
          opacity: 0;
          transform: translateY(12px) scale(0.96) rotate(1deg);
          filter: blur(2px);
        }
      }

      @keyframes flicker {
        0% {
          opacity: 0.6;
          text-shadow: 0 0 6px rgba(0, 243, 255, 0.7);
        }
        100% {
          opacity: 1;
          text-shadow: none;
        }
      }

      @keyframes blink {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0;
        }
      }

      @keyframes arc-breathe {
        0%,
        100% {
          transform: scale(1);
          opacity: 0.8;
        }
        50% {
          transform: scale(1.08);
          opacity: 1;
        }
      }

      @keyframes arc-listen {
        0%,
        100% {
          transform: scale(1);
          opacity: 0.7;
        }
        50% {
          transform: scale(1.15);
          opacity: 1;
        }
      }

      @keyframes arc-speak {
        0% {
          transform: scale(1);
          box-shadow: 0 0 18px rgba(0, 243, 255, 0.4);
        }
        50% {
          transform: scale(1.1);
          box-shadow: 0 0 26px rgba(0, 243, 255, 0.75);
        }
        100% {
          transform: scale(1);
          box-shadow: 0 0 18px rgba(0, 243, 255, 0.4);
        }
      }

      @keyframes arc-think {
        0%,
        100% {
          transform: scale(1);
          opacity: 0.7;
        }
        50% {
          transform: scale(1.12);
          opacity: 1;
        }
      }

      @keyframes pulse {
        0%,
        100% {
          transform: scale(1);
          opacity: 0.7;
        }
        50% {
          transform: scale(1.4);
          opacity: 1;
        }
      }

      @media (max-width: 900px) {
        .grid {
          grid-template-columns: 1fr;
        }

        header h1 {
          font-size: 32px;
        }

        .settings-btn {
          top: 4px;
          right: 4px;
        }

        .memory-input {
          flex-direction: column;
        }

        .command-center {
          width: 120px;
          height: 120px;
        }

        .mic-btn {
          width: 54px;
          height: 54px;
          font-size: 14px;
        }

        .hud-panel {
          min-width: 150px;
        }

        .right-stack {
          gap: 16px;
        }

        .ai-input {
          flex-direction: column;
        }

        .sentry-control {
          flex-direction: column;
          gap: 6px;
        }

        .sonic-footer {
          flex-direction: column;
          justify-content: center;
          gap: 6px;
          padding: 6px 12px;
          height: 80px;
        }

        .sonic-footer canvas {
          height: 80px;
        }

        .net-ghost {
          top: 8px;
          right: 8px;
          font-size: 12px;
          min-width: 150px;
        }
      }
    </style>
  </head>
  <body>
    <div class="scanlines"></div>
    <video
      id="sentryVideo"
      class="sentry-video"
      autoplay
      muted
      playsinline
    ></video>
    <div id="reticle" class="reticle"></div>
    <div id="netGhost" class="net-ghost">
      <div class="ghost-header">
        <span class="ghost-dot"></span>
        NET GHOST PROBE
      </div>
      <div id="ipLine">IP: LOADING...</div>
      <div id="locLine">LOC: UNKNOWN</div>
      <div id="latencyLine">LATENCY: 24ms</div>
    </div>

    <div class="app">
      <header>
        <button
          id="settingsBtn"
          class="settings-btn"
          type="button"
          aria-label="设置"
        >
          ⚙
        </button>
        <h1>The Nexus Terminal</h1>
        <p>神经核心终端 · 挥发记忆池与密码信道并行运行</p>
        <div class="command-center">
          <div id="arcReactor" class="arc-reactor"></div>
          <button id="micBtn" class="mic-btn" type="button">MIC</button>
        </div>
        <div class="hud-panels">
          <div class="hud-panel">
            <div class="hud-title">SYSTEMS</div>
            <div id="batteryLine" class="hud-line">BATTERY: --</div>
            <div id="chargeLine" class="hud-line">STATUS: --</div>
            <div id="cpuLine" class="hud-line">CPU CORES: --</div>
          </div>
          <div class="hud-panel">
            <div class="hud-title">ENV SENSORS</div>
            <div id="tempLine" class="hud-line">TEMP: --</div>
            <div id="windLine" class="hud-line">WIND: --</div>
            <div id="coordLine" class="hud-line">COORD: --</div>
          </div>
        </div>
        <div class="sentry-control">
          <button id="sentryToggle" class="btn secondary sentry-toggle" type="button">
            SENTRY
          </button>
          <span id="sentryStatus" class="sensor-status">SENTRY: OFF</span>
        </div>
      </header>

      <div class="grid">
        <section class="panel">
          <h2>Volatile Memory Pool / 挥发记忆池</h2>
          <div class="memory-input">
            <input
              id="memoryInput"
              type="text"
              placeholder="输入内容后按 Enter 保存..."
              autocomplete="off"
            />
            <button id="addMemory">写入</button>
          </div>
          <div class="memory-hint">左键复制 · 右键删除 · QR 同步</div>
          <div id="memoryGrid" class="data-grid"></div>
        </section>

        <div class="right-stack">
          <section class="panel">
          <h2>Cipher Channel / 密码信道</h2>
          <div class="cipher-tabs panel-tabs">
            <button class="tab-btn panel-tab active" data-panel="cipher">
              CIPHER
            </button>
            <button class="tab-btn panel-tab" data-panel="transmute">
              TRANSMUTE
            </button>
          </div>

          <div id="cipherPanel" class="mode-panel active">
            <div class="cipher-tabs">
              <button class="tab-btn cipher-tab active" data-mode="inject">
                INJECT
              </button>
              <button class="tab-btn cipher-tab" data-mode="extract">
                EXTRACT
              </button>
            </div>

            <div id="injectPanel" class="mode-panel active">
              <div class="field">
                <label>1. 上传载体图片</label>
                <div class="file-actions">
                  <label class="btn file-label">
                    选择图片
                    <input
                      id="injectFile"
                      class="file-input"
                      type="file"
                      accept="image/*"
                    />
                  </label>
                  <button id="injectClear" class="btn secondary" type="button">
                    清除
                  </button>
                </div>
                <div id="injectCapacity" class="memory-hint"></div>
                <img id="injectPreview" class="preview hidden" alt="预览" />
              </div>
              <div class="field">
                <label>2. 输入需要隐藏的文本</label>
                <textarea
                  id="secretInput"
                  placeholder="在这里输入秘密讯息..."
                ></textarea>
              </div>
              <button id="injectBtn">注入并生成</button>
              <a
                id="downloadLink"
                class="download-link disabled"
                href="#"
                download
              >
                下载隐写图像
              </a>
            </div>

            <div id="extractPanel" class="mode-panel">
              <div class="field">
                <label>1. 上传已注入的图片</label>
                <div class="file-actions">
                  <label class="btn file-label">
                    选择图片
                    <input
                      id="extractFile"
                      class="file-input"
                      type="file"
                      accept="image/*"
                    />
                  </label>
                  <button id="extractClear" class="btn secondary" type="button">
                    清除
                  </button>
                </div>
              </div>
              <div class="field">
                <label>2. 解析出的隐藏内容</label>
                <div id="extractOutput" class="output">等待图像输入...</div>
              </div>
            </div>
          </div>

          <div id="transmutePanel" class="mode-panel">
            <div class="field">
              <label>Raw Data Input / 原始数据输入</label>
              <textarea
                id="transmuteInput"
                placeholder="输入文本以转译..."
              ></textarea>
            </div>
            <div class="transmute-grid">
              <div class="field">
                <label>Hexadecimal / 十六进制</label>
                <div id="hexOutput" class="trans-output"></div>
              </div>
              <div class="field">
                <label>Binary / 二进制</label>
                <div id="binOutput" class="trans-output"></div>
              </div>
              <div class="field">
                <label>Base64 / 编码</label>
                <div id="base64Output" class="trans-output"></div>
              </div>
            </div>
          </div>
        </section>
          <section class="panel neural-panel">
            <div class="panel-title-row">
              <h2>Neural Uplink / 神经上行</h2>
              <span class="panel-tag">AI</span>
            </div>
            <div id="aiLog" class="ai-log"></div>
            <div class="ai-input">
              <input
                id="aiInput"
                type="text"
                placeholder="输入指令或问题，Enter 发送..."
                autocomplete="off"
              />
              <button id="aiSend" class="btn secondary" type="button">
                发送
              </button>
            </div>
            <div class="ai-hint">
              关键词指令将直接执行，其余请求接入 AI。
            </div>
          </section>
          <section class="panel protocols-panel">
            <h2>Battle Protocols / 作战协议</h2>
            <div class="protocol-grid">
              <button class="btn protocol-btn" type="button" data-protocol="academic">
                PROTOCOL: ACADEMIC
              </button>
              <button class="btn protocol-btn" type="button" data-protocol="command">
                PROTOCOL: COMMAND
              </button>
              <button class="btn protocol-btn" type="button" data-protocol="total">
                PROTOCOL: TOTAL WAR
              </button>
            </div>
            <div id="popupWarning" class="popup-warning hidden">
              PLEASE ALLOW POPUPS FOR THIS DOMAIN
            </div>
          </section>
        </div>
      </div>
    </div>

    <div id="toast" class="toast">COPIED</div>

    <div id="qrModal" class="modal" aria-hidden="true">
      <div id="qrPanel" class="modal-panel" role="dialog" aria-modal="true">
        <button id="qrClose" class="btn secondary modal-close" type="button">
          X
        </button>
        <h3>Glitch QR Bridge</h3>
        <p>扫描以同步数据块。</p>
        <img id="qrImage" class="qr-image" alt="QR Code" />
        <div id="qrText" class="qr-text"></div>
      </div>
    </div>

    <div id="settingsModal" class="modal" aria-hidden="true">
      <div id="settingsPanel" class="modal-panel" role="dialog" aria-modal="true">
        <button id="settingsClose" class="btn secondary modal-close" type="button">
          X
        </button>
        <h3>Neural Uplink Settings</h3>
        <p>配置 API 端点与密钥，内容仅保存于本地。</p>
        <div class="field">
          <label>API Endpoint</label>
          <input id="apiEndpoint" type="text" placeholder="https://api.openai.com/v1/chat/completions" />
        </div>
        <div class="field">
          <label>API Key</label>
          <input id="apiKey" type="password" placeholder="sk-..." autocomplete="off" />
        </div>
        <div class="field">
          <label>Model</label>
          <input id="apiModel" type="text" placeholder="gpt-3.5-turbo" />
        </div>
        <button id="saveSettings" class="btn" type="button">保存配置</button>
      </div>
    </div>

    <div id="overrideModal" class="override-modal" aria-hidden="true">
      <div class="override-panel">
        <div class="override-title">
          SYSTEM OVERRIDE DETECTED. WELCOME, CREATOR from YUNNAN MINZU UNIVERSITY.
          ACCESS GRANTED.
        </div>
        <div style="margin-top: 16px">
          <button id="overrideClose" class="btn secondary" type="button">
            关闭
          </button>
        </div>
      </div>
    </div>

    <div id="deployOverlay" class="deploy-overlay">DEPLOYING...</div>

    <footer class="sonic-footer">
      <canvas id="sonicCanvas"></canvas>
      <div class="footer-label">SONIC VISUALIZER</div>
      <div class="footer-controls">
        <button id="audioToggle" class="btn footer-btn" type="button">
          INITIALIZE AUDIO
        </button>
        <div id="audioStatus" class="audio-status">AUDIO: OFFLINE</div>
      </div>
    </footer>

    <canvas id="stegCanvas" hidden></canvas>

    <script>
      const STORAGE_KEY = "nexus_memory_v1";
      const AI_ENDPOINT_KEY = "nexus_ai_endpoint";
      const AI_KEY_KEY = "nexus_ai_key";
      const AI_MODEL_KEY = "nexus_ai_model";
      const AI_SYSTEM_PROMPT =
        "You are JARVIS, a helpful AI assistant for a student at Tongji University. Keep responses concise, cool, and tech-focused.";
      const memoryInput = document.getElementById("memoryInput");
      const addMemoryBtn = document.getElementById("addMemory");
      const memoryGrid = document.getElementById("memoryGrid");
      const toast = document.getElementById("toast");

      const injectFile = document.getElementById("injectFile");
      const injectClear = document.getElementById("injectClear");
      const injectBtn = document.getElementById("injectBtn");
      const injectPreview = document.getElementById("injectPreview");
      const injectCapacity = document.getElementById("injectCapacity");
      const secretInput = document.getElementById("secretInput");
      const downloadLink = document.getElementById("downloadLink");

      const extractFile = document.getElementById("extractFile");
      const extractClear = document.getElementById("extractClear");
      const extractOutput = document.getElementById("extractOutput");

      const panelTabs = document.querySelectorAll(".panel-tab");
      const cipherPanel = document.getElementById("cipherPanel");
      const transmutePanel = document.getElementById("transmutePanel");
      const transmuteInput = document.getElementById("transmuteInput");
      const hexOutput = document.getElementById("hexOutput");
      const binOutput = document.getElementById("binOutput");
      const base64Output = document.getElementById("base64Output");
      const aiLog = document.getElementById("aiLog");
      const aiInput = document.getElementById("aiInput");
      const aiSend = document.getElementById("aiSend");
      const settingsBtn = document.getElementById("settingsBtn");
      const settingsModal = document.getElementById("settingsModal");
      const settingsPanel = document.getElementById("settingsPanel");
      const settingsClose = document.getElementById("settingsClose");
      const apiEndpointInput = document.getElementById("apiEndpoint");
      const apiKeyInput = document.getElementById("apiKey");
      const apiModelInput = document.getElementById("apiModel");
      const saveSettingsBtn = document.getElementById("saveSettings");
      const protocolButtons = document.querySelectorAll(".protocol-btn");
      const popupWarning = document.getElementById("popupWarning");
      const deployOverlay = document.getElementById("deployOverlay");

      const ipLine = document.getElementById("ipLine");
      const locLine = document.getElementById("locLine");
      const latencyLine = document.getElementById("latencyLine");

      const batteryLine = document.getElementById("batteryLine");
      const chargeLine = document.getElementById("chargeLine");
      const cpuLine = document.getElementById("cpuLine");
      const tempLine = document.getElementById("tempLine");
      const windLine = document.getElementById("windLine");
      const coordLine = document.getElementById("coordLine");

      const arcReactor = document.getElementById("arcReactor");
      const micBtn = document.getElementById("micBtn");
      const sentryVideo = document.getElementById("sentryVideo");
      const reticle = document.getElementById("reticle");
      const sentryToggle = document.getElementById("sentryToggle");
      const sentryStatus = document.getElementById("sentryStatus");

      const qrModal = document.getElementById("qrModal");
      const qrPanel = document.getElementById("qrPanel");
      const qrClose = document.getElementById("qrClose");
      const qrImage = document.getElementById("qrImage");
      const qrText = document.getElementById("qrText");

      const overrideModal = document.getElementById("overrideModal");
      const overrideClose = document.getElementById("overrideClose");

      const audioToggle = document.getElementById("audioToggle");
      const audioStatus = document.getElementById("audioStatus");
      const sonicCanvas = document.getElementById("sonicCanvas");
      const sonicCtx = sonicCanvas.getContext("2d");

      const canvas = document.getElementById("stegCanvas");
      const ctx = canvas.getContext("2d");

      let memoryList = [];
      let injectImageLoaded = false;
      let typeTimer = null;

      let audioCtx = null;
      let analyser = null;
      let dataArray = null;
      let audioActive = false;
      let fallbackPhase = 0;

      let selectedVoice = null;
      let isListening = false;
      let isSpeaking = false;
      let isThinking = false;
      let currentIp = "UNKNOWN";
      let batteryAlerted = false;
      let sentryActive = false;
      let sentryStream = null;
      let targetX = window.innerWidth / 2;
      let targetY = window.innerHeight / 2;
      let reticleX = targetX;
      let reticleY = targetY;
      let startupSpoken = false;
      let weatherTemp = null;
      let aiHistory = [];
      let aiSettings = {
        endpoint: "https://api.openai.com/v1/chat/completions",
        key: "",
        model: "gpt-3.5-turbo",
      };

      const isUrl = (text) => /^(https?:\/\/|www\.)/i.test(text.trim());
      const isCode = (text) =>
        /[{}`;]|<\/?[a-z][\s\S]*>|(function|const|let|var|=>|#include)/i.test(
          text
        );

      const showToast = (message, tone = "success") => {
        toast.textContent = message;
        toast.style.borderColor =
          tone === "danger" ? "rgba(255, 59, 106, 0.8)" : "rgba(0, 255, 106, 0.8)";
        toast.style.color = tone === "danger" ? "#ff3b6a" : "var(--green)";
        toast.classList.add("show");
        clearTimeout(showToast.timer);
        showToast.timer = setTimeout(() => toast.classList.remove("show"), 1600);
      };

      const updateArcState = () => {
        if (!arcReactor) {
          return;
        }
        arcReactor.classList.remove("listening", "speaking", "thinking");
        if (isListening) {
          arcReactor.classList.add("listening");
          return;
        }
        if (isSpeaking) {
          arcReactor.classList.add("speaking");
          return;
        }
        if (isThinking) {
          arcReactor.classList.add("thinking");
        }
      };

      const pickVoice = () => {
        if (!("speechSynthesis" in window)) {
          return;
        }
        const voices = window.speechSynthesis.getVoices();
        if (!voices.length) {
          return;
        }
        const preferred = [
          "Microsoft David",
          "Google US English Male",
          "Google UK English Male",
          "Alex",
          "Daniel",
          "George",
        ];
        const maleTokens = ["male", "david", "alex", "mark", "george", "daniel"];
        selectedVoice =
          voices.find((voice) =>
            preferred.some((name) => voice.name.includes(name))
          ) ||
          voices.find((voice) =>
            maleTokens.some((token) => voice.name.toLowerCase().includes(token))
          ) ||
          voices.find((voice) => /en(-|_)us/i.test(voice.lang)) ||
          voices.find((voice) => voice.lang && voice.lang.startsWith("en")) ||
          voices[0];
      };

      const speak = (text) => {
        if (!text || !("speechSynthesis" in window)) {
          return;
        }
        window.speechSynthesis.cancel();
        const utterance = new SpeechSynthesisUtterance(text);
        if (selectedVoice) {
          utterance.voice = selectedVoice;
        }
        utterance.rate = 0.95;
        utterance.pitch = 0.8;
        utterance.volume = 1;
        utterance.onstart = () => {
          isSpeaking = true;
          updateArcState();
        };
        utterance.onend = () => {
          isSpeaking = false;
          updateArcState();
        };
        utterance.onerror = () => {
          isSpeaking = false;
          updateArcState();
        };
        window.speechSynthesis.speak(utterance);
      };

      const stopSpeech = () => {
        if ("speechSynthesis" in window) {
          window.speechSynthesis.cancel();
        }
        isSpeaking = false;
        updateArcState();
      };

      const appendLog = (role, text) => {
        if (!aiLog) {
          return null;
        }
        const entry = document.createElement("div");
        entry.className = `ai-entry ${role}`;
        entry.textContent = text;
        aiLog.appendChild(entry);
        aiLog.scrollTop = aiLog.scrollHeight;
        return entry;
      };

      const loadAiSettings = () => {
        const endpoint = localStorage.getItem(AI_ENDPOINT_KEY);
        const key = localStorage.getItem(AI_KEY_KEY);
        const model = localStorage.getItem(AI_MODEL_KEY);
        aiSettings.endpoint = endpoint || aiSettings.endpoint;
        aiSettings.key = key || "";
        aiSettings.model = model || aiSettings.model;
        if (apiEndpointInput) {
          apiEndpointInput.value = aiSettings.endpoint;
        }
        if (apiKeyInput) {
          apiKeyInput.value = aiSettings.key;
        }
        if (apiModelInput) {
          apiModelInput.value = aiSettings.model;
        }
      };

      const closeSettings = () => {
        if (!settingsModal) {
          return;
        }
        settingsModal.classList.remove("active");
        settingsModal.setAttribute("aria-hidden", "true");
      };

      const openSettings = () => {
        if (!settingsModal) {
          return;
        }
        settingsModal.classList.add("active");
        settingsModal.setAttribute("aria-hidden", "false");
        if (apiEndpointInput) {
          apiEndpointInput.focus();
        }
      };

      const saveAiSettings = () => {
        if (apiEndpointInput) {
          const value = apiEndpointInput.value.trim();
          if (value) {
            aiSettings.endpoint = value;
          }
        }
        if (apiKeyInput) {
          aiSettings.key = apiKeyInput.value.trim();
        }
        if (apiModelInput) {
          const value = apiModelInput.value.trim();
          if (value) {
            aiSettings.model = value;
          }
        }
        localStorage.setItem(AI_ENDPOINT_KEY, aiSettings.endpoint);
        if (aiSettings.key) {
          localStorage.setItem(AI_KEY_KEY, aiSettings.key);
        } else {
          localStorage.removeItem(AI_KEY_KEY);
        }
        localStorage.setItem(AI_MODEL_KEY, aiSettings.model);
        showToast("配置已保存");
        closeSettings();
      };

      const setThinking = (state) => {
        isThinking = state;
        updateArcState();
      };

      const sendToAi = async (prompt) => {
        const cleaned = prompt.trim();
        if (!cleaned) {
          return;
        }
        if (!aiSettings.endpoint || !aiSettings.key) {
          showToast("请先配置 API 端点与密钥", "danger");
          appendLog("system", "NEURAL LINK: CONFIG REQUIRED.");
          openSettings();
          return;
        }
        appendLog("user", cleaned);
        aiHistory.push({ role: "user", content: cleaned });
        if (aiHistory.length > 8) {
          aiHistory = aiHistory.slice(-8);
        }
        setThinking(true);
        const thinkingEntry = appendLog("system", "NEURAL LINK: THINKING...");
        try {
          const payload = {
            model: aiSettings.model,
            messages: [
              { role: "system", content: AI_SYSTEM_PROMPT },
              ...aiHistory,
            ],
            temperature: 0.6,
          };
          const response = await fetch(aiSettings.endpoint, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${aiSettings.key}`,
            },
            body: JSON.stringify(payload),
          });
          const rawText = await response.text();
          let data = null;
          if (rawText) {
            try {
              data = JSON.parse(rawText);
            } catch (parseError) {
              throw new Error(
                `INVALID RESPONSE (${response.status}): ${rawText.slice(0, 180)}`
              );
            }
          }
          if (!response.ok) {
            const errorText =
              data && data.error && data.error.message
                ? data.error.message
                : rawText || `${response.status} ${response.statusText}`;
            throw new Error(errorText);
          }
          const message =
            data &&
            data.choices &&
            data.choices[0] &&
            (data.choices[0].message
              ? data.choices[0].message.content
              : data.choices[0].text);
          const answer = message ? message.trim() : "";
          if (!answer) {
            throw new Error(
              rawText
                ? `UNSUPPORTED RESPONSE FORMAT`
                : "EMPTY RESPONSE BODY"
            );
          }
          aiHistory.push({ role: "assistant", content: answer });
          if (aiHistory.length > 8) {
            aiHistory = aiHistory.slice(-8);
          }
          appendLog("assistant", answer);
          if (thinkingEntry) {
            thinkingEntry.textContent = "NEURAL LINK: READY.";
          }
          setThinking(false);
          speak(answer);
        } catch (error) {
          if (thinkingEntry) {
            thinkingEntry.textContent = "NEURAL LINK: ERROR.";
          }
          setThinking(false);
          showToast("AI 请求失败", "danger");
          appendLog("system", `AI ERROR: ${error.message || "UNKNOWN"}`);
        }
      };

      const executeCommand = (transcript) => {
        const clean = transcript.trim().toLowerCase();
        if (!clean) {
          return true;
        }
        const hasWord = (word) => new RegExp(`\\b${word}\\b`, "i").test(clean);
        if (hasWord("status") || hasWord("report")) {
          const time = new Date().toLocaleTimeString("en-US", {
            hour12: false,
            hour: "2-digit",
            minute: "2-digit",
          });
          const ip = currentIp || "UNKNOWN";
          speak(`Status report. Time ${time}. IP ${ip}.`);
          showToast("状态播报完成");
          return true;
        }
        if (hasWord("time")) {
          const time = new Date().toLocaleTimeString("en-US", {
            hour12: false,
            hour: "2-digit",
            minute: "2-digit",
            second: "2-digit",
          });
          speak(`Current time ${time}.`);
          showToast(`当前时间 ${time}`);
          return true;
        }
        if (clean.includes("clear memory")) {
          memoryList = [];
          saveMemory();
          renderMemory();
          showToast("记忆池已清空");
          speak("Memory cleared.");
          return true;
        }
        if (hasWord("silence")) {
          stopAllAudio();
          showToast("已静音");
          return true;
        }
        if (hasWord("red")) {
          applyTheme("red");
          showToast("已切换红色主题");
          return true;
        }
        if (hasWord("blue")) {
          applyTheme("blue");
          showToast("已切换蓝色主题");
          return true;
        }
        if (hasWord("sentry")) {
          if (hasWord("off") || hasWord("disable") || hasWord("stop")) {
            stopSentry();
            showToast("SENTRY 已关闭");
            return true;
          }
          if (hasWord("on") || hasWord("enable") || hasWord("start")) {
            startSentry();
            showToast("SENTRY 已启动");
            return true;
          }
          toggleSentry();
          showToast("SENTRY 已切换");
          return true;
        }
        return false;
      };

      const processInput = (text) => {
        const cleaned = text.trim();
        if (!cleaned) {
          return;
        }
        const executed = executeCommand(cleaned);
        if (executed) {
          appendLog("user", cleaned);
          appendLog("system", "COMMAND EXECUTED.");
          return;
        }
        sendToAi(cleaned);
      };

      const submitAiInput = () => {
        if (!aiInput) {
          return;
        }
        const value = aiInput.value;
        aiInput.value = "";
        processInput(value);
      };

      const setEnvOffline = (keepCoord = false) => {
        tempLine.textContent = "TEMP: SENSOR OFFLINE";
        windLine.textContent = "WIND: SENSOR OFFLINE";
        if (!keepCoord) {
          coordLine.textContent = "COORD: SENSOR OFFLINE";
        }
      };

      const updateBatteryUi = (battery) => {
        const level = Math.round(battery.level * 100);
        batteryLine.textContent = `BATTERY: ${level}%`;
        chargeLine.textContent = `STATUS: ${battery.charging ? "CHARGING" : "ON BATTERY"}`;
        if (level < 20 && !batteryAlerted) {
          speak("Power critical.");
          batteryAlerted = true;
        }
        if (level >= 25) {
          batteryAlerted = false;
        }
      };

      const initBattery = () => {
        if (!navigator.getBattery) {
          batteryLine.textContent = "BATTERY: UNAVAILABLE";
          chargeLine.textContent = "STATUS: OFFLINE";
          return;
        }
        navigator
          .getBattery()
          .then((battery) => {
            updateBatteryUi(battery);
            battery.addEventListener("levelchange", () =>
              updateBatteryUi(battery)
            );
            battery.addEventListener("chargingchange", () =>
              updateBatteryUi(battery)
            );
          })
          .catch(() => {
            batteryLine.textContent = "BATTERY: OFFLINE";
            chargeLine.textContent = "STATUS: OFFLINE";
          });
      };

      const initHardware = () => {
        const cores = navigator.hardwareConcurrency;
        cpuLine.textContent = `CPU CORES: ${typeof cores === "number" ? cores : "UNAVAILABLE"}`;
        initBattery();
      };

      const speakStartup = (tempValue) => {
        if (startupSpoken) {
          return;
        }
        startupSpoken = true;
        const rounded =
          typeof tempValue === "number" && !Number.isNaN(tempValue)
            ? Math.round(tempValue)
            : null;
        const message =
          rounded !== null
            ? `System Online. Temperature is ${rounded} degrees. Welcome back, Sir.`
            : "System Online. Weather sensors offline. Welcome back, Sir.";
        speak(message);
      };

      const initWeather = () => {
        if (!navigator.geolocation) {
          setEnvOffline();
          locLine.textContent = "LOC: SENSOR OFFLINE";
          speakStartup(null);
          return;
        }

        navigator.geolocation.getCurrentPosition(
          async (position) => {
            const { latitude, longitude } = position.coords;
            const latText = latitude.toFixed(2);
            const lonText = longitude.toFixed(2);
            coordLine.textContent = `COORD: ${latText}, ${lonText}`;
            locLine.textContent = `LOC: ${latText}, ${lonText}`;
            try {
              const url = `https://api.open-meteo.com/v1/forecast?latitude=${latitude}&longitude=${longitude}&current_weather=true`;
              const response = await fetch(url);
              if (!response.ok) {
                throw new Error("weather");
              }
              const data = await response.json();
              const current = data.current_weather || {};
              if (typeof current.temperature === "number") {
                weatherTemp = current.temperature;
                tempLine.textContent = `TEMP: ${Math.round(current.temperature)}°C`;
              } else {
                tempLine.textContent = "TEMP: SENSOR OFFLINE";
              }
              if (typeof current.windspeed === "number") {
                windLine.textContent = `WIND: ${Math.round(current.windspeed)} km/h`;
              } else {
                windLine.textContent = "WIND: SENSOR OFFLINE";
              }
              speakStartup(weatherTemp);
            } catch (error) {
              setEnvOffline(true);
              speakStartup(null);
            }
          },
          () => {
            setEnvOffline();
            locLine.textContent = "LOC: SENSOR OFFLINE";
            speakStartup(null);
          },
          { timeout: 8000 }
        );
      };

      const setSentryStatus = (text, offline = false) => {
        if (!sentryStatus) {
          return;
        }
        sentryStatus.textContent = text;
        sentryStatus.classList.toggle("offline", offline);
      };

      const startSentry = async () => {
        if (sentryActive) {
          return;
        }
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          setSentryStatus("SENTRY: OFFLINE", true);
          return;
        }
        try {
          sentryStream = await navigator.mediaDevices.getUserMedia({
            video: true,
          });
          sentryVideo.srcObject = sentryStream;
          await sentryVideo.play();
          sentryActive = true;
          document.body.classList.add("sentry");
          reticle.classList.add("active");
          setSentryStatus("SENTRY: ONLINE");
        } catch (error) {
          sentryActive = false;
          if (sentryStream) {
            sentryStream.getTracks().forEach((track) => track.stop());
            sentryStream = null;
          }
          setSentryStatus("SENTRY: OFFLINE", true);
          document.body.classList.remove("sentry");
          reticle.classList.remove("active");
        }
      };

      const stopSentry = () => {
        if (sentryStream) {
          sentryStream.getTracks().forEach((track) => track.stop());
        }
        sentryStream = null;
        sentryVideo.srcObject = null;
        sentryActive = false;
        document.body.classList.remove("sentry");
        reticle.classList.remove("active");
        setSentryStatus("SENTRY: OFF");
      };

      const toggleSentry = () => {
        if (sentryActive) {
          stopSentry();
        } else {
          startSentry();
        }
      };

      const initSentry = () => {
        if (!sentryToggle) {
          return;
        }
        setSentryStatus("SENTRY: OFF");
        sentryToggle.addEventListener("click", toggleSentry);
      };

      const animateReticle = () => {
        if (reticle) {
          const ease = sentryActive ? 0.12 : 0.06;
          reticleX += (targetX - reticleX) * ease;
          reticleY += (targetY - reticleY) * ease;
          reticle.style.left = `${reticleX}px`;
          reticle.style.top = `${reticleY}px`;
        }
        requestAnimationFrame(animateReticle);
      };

      const saveMemory = () => {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(memoryList));
      };

      const renderMemory = () => {
        memoryGrid.innerHTML = "";
        if (!memoryList.length) {
          const empty = document.createElement("div");
          empty.className = "memory-hint";
          empty.textContent = "尚无数据块，输入内容后敲 Enter 写入。";
          memoryGrid.appendChild(empty);
          return;
        }

        memoryList.forEach((item, index) => {
          const block = document.createElement("div");
          block.className = "data-block";
          block.dataset.index = index;

          const tagParts = [];
          if (isUrl(item)) {
            block.classList.add("link");
            tagParts.push("URL");
          }
          if (isCode(item)) {
            block.classList.add("code");
            tagParts.push("CODE");
          }

          const head = document.createElement("div");
          head.className = "block-head";

          const meta = document.createElement("div");
          meta.className = "block-meta";
          const idSpan = document.createElement("span");
          idSpan.textContent = `#${String(index + 1).padStart(3, "0")}`;
          meta.appendChild(idSpan);

          if (tagParts.length) {
            tagParts.forEach((tag) => {
              const flag = document.createElement("span");
              flag.className = "block-flag" + (tag === "CODE" ? " code" : "");
              flag.textContent = tag;
              meta.appendChild(flag);
            });
          }

          const actions = document.createElement("div");
          actions.className = "block-actions";

          const qrBtn = document.createElement("button");
          qrBtn.type = "button";
          qrBtn.className = "icon-btn qr-btn";
          qrBtn.title = "生成 QR";
          qrBtn.textContent = "QR";
          qrBtn.addEventListener("click", (event) => {
            event.stopPropagation();
            openQrModal(item);
          });

          const delBtn = document.createElement("button");
          delBtn.type = "button";
          delBtn.className = "icon-btn delete-btn";
          delBtn.title = "删除";
          delBtn.textContent = "X";
          delBtn.addEventListener("click", (event) => {
            event.stopPropagation();
            deleteBlock(block);
          });

          actions.appendChild(qrBtn);
          actions.appendChild(delBtn);

          head.appendChild(meta);
          head.appendChild(actions);

          const content = document.createElement("div");
          content.className = "block-content";
          content.textContent =
            item.length > 140 ? `${item.slice(0, 140)}...` : item;
          content.title = item;

          block.appendChild(head);
          block.appendChild(content);

          block.addEventListener("click", () => copyToClipboard(item));
          block.addEventListener("contextmenu", (event) => {
            event.preventDefault();
            deleteBlock(block);
          });

          memoryGrid.appendChild(block);
        });
      };

      const copyToClipboard = async (text) => {
        try {
          if (navigator.clipboard && window.isSecureContext) {
            await navigator.clipboard.writeText(text);
          } else {
            const temp = document.createElement("textarea");
            temp.value = text;
            document.body.appendChild(temp);
            temp.select();
            document.execCommand("copy");
            document.body.removeChild(temp);
          }
          showToast("COPIED: 已写入剪贴板");
          speak("Data copied.");
        } catch (error) {
          showToast("复制失败，请重试", "danger");
        }
      };

      const deleteBlock = (block) => {
        const index = Number(block.dataset.index);
        block.classList.add("shatter");
        block.addEventListener(
          "animationend",
          () => {
            memoryList.splice(index, 1);
            saveMemory();
            renderMemory();
          },
          { once: true }
        );
      };

      const addMemory = () => {
        const text = memoryInput.value.trim();
        if (!text) {
          return;
        }
        memoryList.unshift(text);
        memoryInput.value = "";
        saveMemory();
        renderMemory();
      };

      addMemoryBtn.addEventListener("click", addMemory);
      memoryInput.addEventListener("keydown", (event) => {
        if (event.key === "Enter") {
          event.preventDefault();
          addMemory();
        }
      });

      const loadMemory = () => {
        const saved = localStorage.getItem(STORAGE_KEY);
        if (saved) {
          try {
            const parsed = JSON.parse(saved);
            if (Array.isArray(parsed)) {
              memoryList = parsed;
            }
          } catch (error) {
            memoryList = [];
          }
        }
        renderMemory();
      };

      const openQrModal = (text) => {
        const encoded = encodeURIComponent(text);
        qrImage.src = `https://api.qrserver.com/v1/create-qr-code/?size=150x150&data=${encoded}`;
        qrText.textContent = text;
        qrModal.classList.add("active");
        qrModal.setAttribute("aria-hidden", "false");
        qrPanel.classList.remove("glitch-in");
        void qrPanel.offsetWidth;
        qrPanel.classList.add("glitch-in");
      };

      const closeQrModal = () => {
        qrModal.classList.remove("active");
        qrModal.setAttribute("aria-hidden", "true");
      };

      qrClose.addEventListener("click", closeQrModal);
      qrModal.addEventListener("click", (event) => {
        if (event.target === qrModal) {
          closeQrModal();
        }
      });

      if (settingsBtn) {
        settingsBtn.addEventListener("click", openSettings);
      }
      if (settingsClose) {
        settingsClose.addEventListener("click", closeSettings);
      }
      if (settingsModal) {
        settingsModal.addEventListener("click", (event) => {
          if (event.target === settingsModal) {
            closeSettings();
          }
        });
      }
      if (saveSettingsBtn) {
        saveSettingsBtn.addEventListener("click", saveAiSettings);
      }

      if (aiSend) {
        aiSend.addEventListener("click", submitAiInput);
      }
      if (aiInput) {
        aiInput.addEventListener("keydown", (event) => {
          if (event.key === "Enter") {
            event.preventDefault();
            submitAiInput();
          }
        });
      }

      protocolButtons.forEach((button) => {
        button.addEventListener("click", () => {
          const key = button.dataset.protocol;
          launchProtocol(key);
        });
      });

      panelTabs.forEach((btn) => {
        btn.addEventListener("click", () => {
          panelTabs.forEach((item) => item.classList.remove("active"));
          btn.classList.add("active");
          const panel = btn.dataset.panel;
          cipherPanel.classList.toggle("active", panel === "cipher");
          transmutePanel.classList.toggle("active", panel === "transmute");
        });
      });

      document.querySelectorAll(".cipher-tab").forEach((btn) => {
        btn.addEventListener("click", () => {
          document
            .querySelectorAll(".cipher-tab")
            .forEach((item) => item.classList.remove("active"));
          btn.classList.add("active");

          const mode = btn.dataset.mode;
          document.getElementById("injectPanel").classList.toggle(
            "active",
            mode === "inject"
          );
          document.getElementById("extractPanel").classList.toggle(
            "active",
            mode === "extract"
          );
        });
      });

      const loadImageToCanvas = (file, callback, previewEl) => {
        const reader = new FileReader();
        reader.onload = () => {
          const img = new Image();
          img.onload = () => {
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            callback(img);
          };
          img.src = reader.result;
          if (previewEl) {
            previewEl.src = reader.result;
            previewEl.classList.remove("hidden");
          }
        };
        reader.readAsDataURL(file);
      };

      const getCapacityBytes = () => {
        const totalBits = canvas.width * canvas.height * 3;
        return Math.max(0, Math.floor((totalBits - 32) / 8));
      };

      const encodeLSB = (imageData, payload) => {
        const data = imageData.data;
        const capacityBits = (data.length / 4) * 3;
        const totalBits = 32 + payload.length * 8;
        if (totalBits > capacityBits) {
          throw new Error("超出容量");
        }

        let bitIndex = 0;
        const writeBit = (bit) => {
          const channelIndex = bitIndex % 3;
          const pixelIndex = Math.floor(bitIndex / 3);
          const dataIndex = pixelIndex * 4 + channelIndex;
          data[dataIndex] = (data[dataIndex] & 0xfe) | bit;
          bitIndex += 1;
        };

        for (let i = 31; i >= 0; i -= 1) {
          writeBit((payload.length >> i) & 1);
        }

        payload.forEach((byte) => {
          for (let i = 7; i >= 0; i -= 1) {
            writeBit((byte >> i) & 1);
          }
        });

        return imageData;
      };

      const decodeLSB = (imageData) => {
        const data = imageData.data;
        const capacityBits = (data.length / 4) * 3;
        if (capacityBits < 32) {
          throw new Error("图像尺寸过小");
        }

        const readBit = (bitIndex) => {
          const channelIndex = bitIndex % 3;
          const pixelIndex = Math.floor(bitIndex / 3);
          const dataIndex = pixelIndex * 4 + channelIndex;
          return data[dataIndex] & 1;
        };

        let length = 0;
        for (let i = 0; i < 32; i += 1) {
          length = (length << 1) | readBit(i);
        }

        const totalBits = 32 + length * 8;
        if (totalBits > capacityBits) {
          throw new Error("未检测到有效内容");
        }

        const bytes = new Uint8Array(length);
        let offset = 32;
        for (let i = 0; i < length; i += 1) {
          let value = 0;
          for (let bit = 0; bit < 8; bit += 1) {
            value = (value << 1) | readBit(offset + bit);
          }
          bytes[i] = value;
          offset += 8;
        }

        return new TextDecoder().decode(bytes);
      };

      const bytesToHex = (bytes) =>
        Array.from(bytes)
          .map((byte) => byte.toString(16).padStart(2, "0"))
          .join(" ");

      const bytesToBin = (bytes) =>
        Array.from(bytes)
          .map((byte) => byte.toString(2).padStart(8, "0"))
          .join(" ");

      const bytesToBase64 = (bytes) => {
        if (!bytes.length) {
          return "";
        }
        let binary = "";
        bytes.forEach((byte) => {
          binary += String.fromCharCode(byte);
        });
        return btoa(binary);
      };

      const triggerFlicker = (element) => {
        if (!element) {
          return;
        }
        element.classList.remove("flicker");
        void element.offsetWidth;
        element.classList.add("flicker");
        clearTimeout(element.flickerTimer);
        element.flickerTimer = setTimeout(
          () => element.classList.remove("flicker"),
          260
        );
      };

      const updateTransmute = () => {
        const text = transmuteInput.value;
        if (!text) {
          hexOutput.textContent = "";
          binOutput.textContent = "";
          base64Output.textContent = "";
          return;
        }
        const bytes = new TextEncoder().encode(text);
        hexOutput.textContent = bytesToHex(bytes);
        binOutput.textContent = bytesToBin(bytes);
        let base64 = "";
        try {
          base64 = bytesToBase64(bytes);
        } catch (error) {
          base64 = "";
        }
        base64Output.textContent = base64;
        [hexOutput, binOutput, base64Output].forEach(triggerFlicker);
      };

      const resetInject = () => {
        injectFile.value = "";
        injectPreview.src = "";
        injectPreview.classList.add("hidden");
        injectImageLoaded = false;
        injectCapacity.textContent = "";
        downloadLink.href = "#";
        downloadLink.classList.add("disabled");
      };

      const resetExtract = () => {
        extractFile.value = "";
        extractOutput.textContent = "等待图像输入...";
        extractOutput.classList.remove("typing");
        clearInterval(typeTimer);
        canvas.width = 0;
        canvas.height = 0;
      };

      injectFile.addEventListener("change", (event) => {
        const file = event.target.files[0];
        if (!file) {
          return;
        }
        downloadLink.href = "#";
        downloadLink.classList.add("disabled");
        loadImageToCanvas(
          file,
          () => {
            injectImageLoaded = true;
            const capacity = getCapacityBytes();
            injectCapacity.textContent = `可容纳约 ${capacity} 字节数据`;
          },
          injectPreview
        );
      });

      injectBtn.addEventListener("click", () => {
        if (!injectImageLoaded) {
          showToast("请先选择图片", "danger");
          return;
        }
        const secret = secretInput.value;
        if (!secret.trim()) {
          showToast("请输入需要隐藏的文本", "danger");
          return;
        }

        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const bytes = new TextEncoder().encode(secret);
        try {
          const encoded = encodeLSB(imageData, bytes);
          ctx.putImageData(encoded, 0, 0);
          const url = canvas.toDataURL("image/png");
          downloadLink.href = url;
          downloadLink.classList.remove("disabled");
          showToast("注入完成，可下载图像");
          speak("Encryption complete.");
        } catch (error) {
          showToast("文本过长，超出图像容量！", "danger");
        }
      });

      downloadLink.addEventListener("click", (event) => {
        if (downloadLink.classList.contains("disabled")) {
          event.preventDefault();
        }
      });

      injectClear.addEventListener("click", resetInject);

      const typewriter = (element, text) => {
        clearInterval(typeTimer);
        element.textContent = "";
        element.classList.add("typing");
        let index = 0;
        typeTimer = setInterval(() => {
          element.textContent = text.slice(0, index);
          index += 1;
          if (index > text.length) {
            clearInterval(typeTimer);
            element.classList.remove("typing");
          }
        }, 30);
      };

      extractFile.addEventListener("change", (event) => {
        const file = event.target.files[0];
        if (!file) {
          return;
        }
        loadImageToCanvas(file, () => {
          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
          try {
            const message = decodeLSB(imageData);
            typewriter(
              extractOutput,
              message || "未检测到隐藏内容，可能为空或损坏。"
            );
          } catch (error) {
            typewriter(extractOutput, "解析失败：无法读取隐藏内容。");
          }
        });
      });

      extractClear.addEventListener("click", resetExtract);
      transmuteInput.addEventListener("input", updateTransmute);

      const resizeSonic = () => {
        const dpr = window.devicePixelRatio || 1;
        const rect = sonicCanvas.getBoundingClientRect();
        sonicCanvas.width = rect.width * dpr;
        sonicCanvas.height = rect.height * dpr;
        sonicCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
      };

      const drawSonic = () => {
        requestAnimationFrame(drawSonic);
        const width = sonicCanvas.clientWidth;
        const height = sonicCanvas.clientHeight;
        if (!width || !height) {
          return;
        }

        sonicCtx.clearRect(0, 0, width, height);
        sonicCtx.fillStyle = "rgba(5, 5, 5, 0.85)";
        sonicCtx.fillRect(0, 0, width, height);

        sonicCtx.strokeStyle = "rgba(0, 243, 255, 0.12)";
        sonicCtx.lineWidth = 1;
        for (let i = 1; i <= 3; i += 1) {
          const y = (height / 4) * i;
          sonicCtx.beginPath();
          sonicCtx.moveTo(0, y);
          sonicCtx.lineTo(width, y);
          sonicCtx.stroke();
        }

        const barCount = dataArray ? dataArray.length : 64;
        const barWidth = width / barCount;

        if (analyser && audioCtx && audioCtx.state === "running") {
          analyser.getByteFrequencyData(dataArray);
        } else {
          if (!dataArray) {
            dataArray = new Uint8Array(64);
          }
          for (let i = 0; i < dataArray.length; i += 1) {
            dataArray[i] =
              40 +
              30 * Math.sin(fallbackPhase + i * 0.35) +
              12 * Math.sin(fallbackPhase * 0.6 + i * 0.15);
          }
          fallbackPhase += 0.04;
        }

        sonicCtx.shadowColor = "rgba(0, 243, 255, 0.6)";
        sonicCtx.shadowBlur = 10;
        sonicCtx.fillStyle = "rgba(0, 243, 255, 0.8)";

        for (let i = 0; i < barCount; i += 1) {
          const value = dataArray[i] / 255;
          const barHeight = Math.max(4, value * (height - 10));
          const x = i * barWidth;
          const y = height - barHeight;
          sonicCtx.fillRect(x, y, Math.max(1, barWidth - 1), barHeight);
        }

        sonicCtx.shadowBlur = 0;
      };

      const initAudio = () => {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        analyser = audioCtx.createAnalyser();
        analyser.fftSize = 256;
        dataArray = new Uint8Array(analyser.frequencyBinCount);

        const masterGain = audioCtx.createGain();
        masterGain.gain.value = 0.08;

        const osc1 = audioCtx.createOscillator();
        osc1.type = "sawtooth";
        osc1.frequency.value = 70;

        const osc2 = audioCtx.createOscillator();
        osc2.type = "triangle";
        osc2.frequency.value = 112;

        const noiseBuffer = audioCtx.createBuffer(
          1,
          audioCtx.sampleRate * 2,
          audioCtx.sampleRate
        );
        const noiseData = noiseBuffer.getChannelData(0);
        for (let i = 0; i < noiseData.length; i += 1) {
          noiseData[i] = (Math.random() * 2 - 1) * 0.25;
        }
        const noise = audioCtx.createBufferSource();
        noise.buffer = noiseBuffer;
        noise.loop = true;
        const noiseGain = audioCtx.createGain();
        noiseGain.gain.value = 0.03;

        const lfo = audioCtx.createOscillator();
        lfo.frequency.value = 0.4;
        const lfoGain = audioCtx.createGain();
        lfoGain.gain.value = 0.02;

        lfo.connect(lfoGain);
        lfoGain.connect(masterGain.gain);

        osc1.connect(masterGain);
        osc2.connect(masterGain);
        noise.connect(noiseGain);
        noiseGain.connect(masterGain);

        masterGain.connect(analyser);
        analyser.connect(audioCtx.destination);

        osc1.start();
        osc2.start();
        noise.start();
        lfo.start();
      };

      const updateAudioUi = () => {
        audioToggle.textContent = audioActive ? "MUTE AUDIO" : "INITIALIZE AUDIO";
        audioStatus.textContent = audioActive ? "AUDIO: ONLINE" : "AUDIO: OFFLINE";
      };

      const stopAllAudio = () => {
        stopSpeech();
        if (audioCtx && audioCtx.state === "running") {
          audioCtx.suspend();
        }
        audioActive = false;
        updateAudioUi();
      };

      const toggleAudio = async () => {
        if (!audioCtx) {
          initAudio();
        }
        if (audioCtx.state === "suspended") {
          await audioCtx.resume();
          audioActive = true;
        } else {
          await audioCtx.suspend();
          audioActive = false;
        }
        updateAudioUi();
      };

      const playLaunchSound = () => {
        const useShared = audioCtx && audioActive && audioCtx.state === "running";
        const ctxToUse =
          useShared
            ? audioCtx
            : new (window.AudioContext || window.webkitAudioContext)();
        const osc = ctxToUse.createOscillator();
        const gain = ctxToUse.createGain();
        const now = ctxToUse.currentTime;
        osc.type = "sawtooth";
        osc.frequency.setValueAtTime(160, now);
        osc.frequency.exponentialRampToValueAtTime(45, now + 0.6);
        gain.gain.setValueAtTime(0.0001, now);
        gain.gain.exponentialRampToValueAtTime(0.25, now + 0.08);
        gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.6);
        osc.connect(gain);
        gain.connect(ctxToUse.destination);
        osc.start(now);
        osc.stop(now + 0.65);
        if (!useShared) {
          osc.onended = () => ctxToUse.close();
        }
      };

      const showDeployOverlay = () => {
        if (!deployOverlay) {
          return;
        }
        deployOverlay.classList.add("active");
        clearTimeout(showDeployOverlay.timer);
        showDeployOverlay.timer = setTimeout(
          () => deployOverlay.classList.remove("active"),
          1200
        );
      };

      const protocolSets = {
        academic: [
          "https://gemini.google.com/",
          "http://1.tongji.edu.cn/",
          "https://canvas.tongji.edu.cn/",
          "https://github.com/",
        ],
        command: ["https://shen806.dpdns.org/", "https://shen.chat/"],
      };
      protocolSets.total = Array.from(
        new Set([...protocolSets.academic, ...protocolSets.command])
      );

      const launchProtocol = (key) => {
        const urls = protocolSets[key];
        if (!urls) {
          return;
        }
        showDeployOverlay();
        playLaunchSound();
        let blocked = false;
        urls.forEach((url) => {
          const win = window.open(url, "_blank");
          if (!win) {
            blocked = true;
          }
        });
        if (popupWarning) {
          popupWarning.classList.toggle("hidden", !blocked);
        }
        if (blocked) {
          showToast("弹窗被拦截，请允许弹窗", "danger");
        }
      };

      audioToggle.addEventListener("click", toggleAudio);

      const playBeep = () => {
        const ctxToUse = audioCtx || new (window.AudioContext || window.webkitAudioContext)();
        const osc = ctxToUse.createOscillator();
        const gain = ctxToUse.createGain();
        osc.type = "square";
        osc.frequency.value = 880;
        gain.gain.value = 0.2;
        osc.connect(gain);
        gain.connect(ctxToUse.destination);
        ctxToUse.resume();
        osc.start();
        gain.gain.exponentialRampToValueAtTime(0.0001, ctxToUse.currentTime + 0.2);
        osc.stop(ctxToUse.currentTime + 0.25);
        if (!audioCtx) {
          osc.onended = () => ctxToUse.close();
        }
      };

      const konamiSequence = [
        "ArrowUp",
        "ArrowUp",
        "ArrowDown",
        "ArrowDown",
        "ArrowLeft",
        "ArrowRight",
        "ArrowLeft",
        "ArrowRight",
        "b",
        "a",
      ];
      let konamiIndex = 0;

      const normalizeKey = (key) =>
        key.startsWith("Arrow") ? key : key.toLowerCase();

      const triggerKonami = () => {
        playBeep();
        speak("System Override engaged.");
        document.body.classList.add("override");
        overrideModal.classList.add("active");
        overrideModal.setAttribute("aria-hidden", "false");
      };

      document.addEventListener("keydown", (event) => {
        const key = normalizeKey(event.key);
        const expected = konamiSequence[konamiIndex];
        if (key === expected) {
          konamiIndex += 1;
          if (konamiIndex === konamiSequence.length) {
            konamiIndex = 0;
            triggerKonami();
          }
        } else {
          konamiIndex = key === konamiSequence[0] ? 1 : 0;
        }
      });

      const closeOverride = () => {
        overrideModal.classList.remove("active");
        overrideModal.setAttribute("aria-hidden", "true");
        document.body.classList.remove("override");
      };

      overrideClose.addEventListener("click", closeOverride);
      overrideModal.addEventListener("click", (event) => {
        if (event.target === overrideModal) {
          closeOverride();
        }
      });

      const updateLatency = () => {
        const value = Math.floor(18 + Math.random() * 60);
        latencyLine.textContent = `LATENCY: ${value}ms`;
      };

      const applyTheme = (mode) => {
        const root = document.documentElement;
        if (mode === "red") {
          root.style.setProperty("--cyan", "#ff3b3b");
          root.style.setProperty("--purple", "#ff0066");
          root.style.setProperty("--green", "#ff8a8a");
          root.style.setProperty("--text", "#ffecec");
          root.style.setProperty("--muted", "#ffb3b3");
          return;
        }
        root.style.setProperty("--cyan", "#00f3ff");
        root.style.setProperty("--purple", "#bd00ff");
        root.style.setProperty("--green", "#00ff6a");
        root.style.setProperty("--text", "#d7f8ff");
        root.style.setProperty("--muted", "#7be7ff");
      };

      const handleCommand = (transcript) => {
        processInput(transcript);
      };

      const initSpeech = () => {
        if (!("speechSynthesis" in window)) {
          return;
        }
        pickVoice();
        window.speechSynthesis.onvoiceschanged = pickVoice;
      };

      const initRecognition = () => {
        const SpeechRecognition =
          window.SpeechRecognition || window.webkitSpeechRecognition;
        if (!SpeechRecognition) {
          if (micBtn) {
            micBtn.style.display = "none";
          }
          showToast("语音识别不可用", "danger");
          return;
        }
        const recognition = new SpeechRecognition();
        recognition.lang = "en-US";
        recognition.interimResults = false;
        recognition.maxAlternatives = 1;

        recognition.onstart = () => {
          isListening = true;
          updateArcState();
          micBtn.classList.add("recording");
          micBtn.textContent = "REC";
        };

        recognition.onend = () => {
          isListening = false;
          updateArcState();
          micBtn.classList.remove("recording");
          micBtn.textContent = "MIC";
        };

        recognition.onerror = () => {
          showToast("语音识别失败", "danger");
        };

        recognition.onresult = (event) => {
          const transcript = event.results[0][0].transcript;
          handleCommand(transcript);
        };

        micBtn.addEventListener("click", () => {
          if (isListening) {
            recognition.stop();
          } else {
            recognition.start();
          }
        });
      };

      const loadIpAddress = async () => {
        try {
          const response = await fetch("https://api.ipify.org?format=json");
          const data = await response.json();
          currentIp = data.ip || "UNKNOWN";
          ipLine.textContent = `IP: ${currentIp}`;
        } catch (error) {
          currentIp = "OFFLINE";
          ipLine.textContent = "IP: OFFLINE";
        }
      };

      updateLatency();
      setInterval(updateLatency, 2000);
      loadIpAddress();
      initSpeech();
      initRecognition();
      initHardware();
      initWeather();
      initSentry();
      loadAiSettings();
      appendLog("system", "NEURAL LINK: READY.");

      window.addEventListener("resize", () => {
        resizeSonic();
        targetX = window.innerWidth / 2;
        targetY = window.innerHeight / 2;
      });
      window.addEventListener("mousemove", (event) => {
        targetX = event.clientX;
        targetY = event.clientY;
      });
      window.addEventListener(
        "touchmove",
        (event) => {
          const touch = event.touches[0];
          if (!touch) {
            return;
          }
          targetX = touch.clientX;
          targetY = touch.clientY;
        },
        { passive: true }
      );

      loadMemory();
      resetInject();
      resetExtract();
      updateTransmute();
      resizeSonic();
      drawSonic();
      animateReticle();
    </script>
  </body>
</html>
